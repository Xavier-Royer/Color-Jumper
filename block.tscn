[gd_scene load_steps=12 format=3 uid="uid://qt0hublfhka5"]

[ext_resource type="Script" uid="uid://6q3vbqb2ecbh" path="res://block.gd" id="1_im0tn"]
[ext_resource type="Material" uid="uid://k8pg0755hjfy" path="res://NormalBlockCaught.tres" id="2_5d32t"]
[ext_resource type="Material" uid="uid://bu48js7s1b6pi" path="res://normalDead.tres" id="3_5d32t"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_xfwl5"]
size = Vector2(72.5925, 72.5925)

[sub_resource type="CircleShape2D" id="CircleShape2D_im0tn"]
radius = 21.1123

[sub_resource type="Shader" id="Shader_im0tn"]
code = "shader_type canvas_item;
uniform bool rainbow;
uniform float speed;
uniform float RAINBOWSPEED = 0.1;






vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec3 getColor(int i, float squishness) {
    float hue = float(i) / squishness;
    return hsv2rgb(vec3(hue, 1.0, 1.0));
}
   
    //vec3(1.0, 0.0, 0.0),       // Neon Red
    //vec3(1.0, 0.647, 0.0),     // Electric Orange
    //vec3(1.0, 1.0, 0.0),       // Laser Yellow
    //vec3(0.0, 1.0, 0.0),       // Neon Green
    //vec3(0.0, 1.0, 1.0),       // Aqua Cyan
    //vec3(0.0, 0.0, 1.0),       // Neon Blue
    //vec3(0.294, 0.0, 0.51),    // Indigo Pulse
    //vec3(0.933, 0.51, 0.933),  // Vivid Violet
    //vec3(1.0, 0.078, 0.576),   // Hot Pink
    //vec3(1.0, 0.0, 1.0)        // Magenta Glow
//};


void vertex() {
	// Called for every vertex the material is visible on.
}

void fragment() {
	if (true){
		vec4 input_color = texture(TEXTURE,UV);
		float xPos = 2.0*abs(0.5-UV.x);
		float yPos = 2.0*abs(0.5-UV.y);
		//for circluar shader
		//float radius = pow(pow(xPos,2.0) + pow(yPos,2.0),0.5);
		//float alpha = 1.0-(radius/1.1);
		//COLOR.a = alpha;

		//for square shader
		float squareRadius = max(xPos,yPos);
		
		//squareRadius = round(squareRadius*15.0)/15.0;
		
		float alpha = 1.0-(squareRadius/1.1); //1.0-(squareRadius/1.5);
		alpha += sin(TIME*10.0)/20.0;
	
		if (rainbow) {
				//clamp first value between 0 and 1
			//COLOR = vec4(  max(UV.y * ((sin(TIME*2.0)+2.5)/2.5),0.3)   , max(((UV.x)/2.0) * ((sin(TIME*2.0 +(PI/2.0))+2.5)/2.5),0.35)  ,  max((UV.x+UV.y)/2.0 * ((sin(TIME*2.0 +(PI/4.0))+2.5)/2.5),0.6),  COLOR.a);
			//COLOR = vec4( squareRadius* max((sin(5.0*TIME+(PI/2.0))+1.0)/2.0,0.4) , squareRadius * (sin(5.0*TIME+(PI/4.0))+1.0)/2.0, (sin(5.0*TIME)+1.0)/2.0,1.0);
			
			//old rainbow code
			//COLOR = vec4(  ((sin( (speed*TIME) + (UV.x * UV.y) + (PI/4.0) ))+ 1.0)/2.0, max((sin( (speed*TIME) +(UV.x * UV.y) + (PI/2.0) )+1.0)/2.0,0.5), (sin( (speed*TIME) +(UV.x * UV.y) )+1.0)/2.0, 1.0);
			//alpha -=0.1;
			
			float xValue = 1.0 - max(xPos,yPos);
			xValue = UV.x+UV.y;
			float offset;  
			

			offset = mod(TIME/2.0,4);
			xValue = xValue + offset;
			
			//xValue = mod(TIME/0.5,4);
			
			//if (xValue > 1.0){
			//	xValue -=1.0;
			//}
			
			//xValue = xValue /2.0;
			
				
			
			
			float indexf = (floor(xValue*25.0));
			//index =10;
			int index = int(indexf);
			COLOR.r = getColor(index,33.3).x;
			COLOR.g = getColor(index,33.3).y;
			COLOR.b = getColor(index,33.3).z;
			
		}
		
		if (squareRadius >0.55){
			//uses +1 to allow for animation player to change alpha value
			COLOR.a += clamp(0.0,alpha,1.0) -1.0;
			if (! rainbow){
				COLOR.b *=2.8;
				COLOR.r *=2.8;
				COLOR.g *=2.8;
			}
			
			if (rainbow){
				
				float xValue = 1.0- max(xPos,yPos) ;
				xValue = (UV.x+UV.y);
				float offset;  
				offset = mod((TIME+0.0)/1.0,4);
				xValue = xValue + offset;
			
				float indexf = (floor(xValue*25.0));
				int index = int(indexf);
				COLOR.r = getColor(index,20.0).x;
				COLOR.g = getColor(index,20.0).y;
				COLOR.b = getColor(index,20.0).z;

				COLOR.a += sin(TIME*10.0)/40.0;
				COLOR.b *=0.3;
				COLOR.r *=0.3;
				COLOR.g *=0.3;
			}
			
		}
		if (squareRadius >0.0 && squareRadius < 0.55){
			if ( UV.y >0.65){
				COLOR.a  = 0.7;
				COLOR.b *=0.8;
				COLOR.r *=0.8;
				COLOR.g *=0.8;
			}
			}
		
		
	
}




	//COLOR = vec4(input_color.r,input_color.g,input_color.b,alpha);

	//COLOR = vec4(squareRadius, 0.0, 0.0,1.0); // Shows UV gradient from red (X) and green (Y)
}

//void light() {
//	// Called for every pixel for every light affecting the CanvasItem.
//	// Uncomment to replace the default light processing function with this one.
//}
"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_5d32t"]
shader = SubResource("Shader_im0tn")
shader_parameter/rainbow = true
shader_parameter/speed = 2.0
shader_parameter/RAINBOWSPEED = 2.0

[sub_resource type="Animation" id="Animation_5d32t"]
resource_name = "CaughtBlock"
length = 0.1
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath("ColorRect:scale")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0, 0.05, 0.1),
"transitions": PackedFloat32Array(1, 1, 1),
"update": 0,
"values": [Vector2(1, 1), Vector2(1.3, 1.3), Vector2(1, 1)]
}
tracks/1/type = "value"
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/path = NodePath("ColorRect:color:a")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/keys = {
"times": PackedFloat32Array(0, 0.05, 0.2),
"transitions": PackedFloat32Array(1, 1, 1),
"update": 0,
"values": [1.0, Color(0, 0, 0, 0.756863), 1.0]
}

[sub_resource type="Animation" id="Animation_xfwl5"]
length = 0.001
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath(".:rotation")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [0.0]
}
tracks/1/type = "value"
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/path = NodePath(".:scale")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Vector2(6, 6)]
}
tracks/2/type = "value"
tracks/2/imported = false
tracks/2/enabled = true
tracks/2/path = NodePath("ColorRect:scale")
tracks/2/interp = 1
tracks/2/loop_wrap = true
tracks/2/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [Vector2(1, 1)]
}
tracks/3/type = "value"
tracks/3/imported = false
tracks/3/enabled = true
tracks/3/path = NodePath("ColorRect:color:a")
tracks/3/interp = 1
tracks/3/loop_wrap = true
tracks/3/keys = {
"times": PackedFloat32Array(0),
"transitions": PackedFloat32Array(1),
"update": 0,
"values": [1.0]
}

[sub_resource type="Animation" id="Animation_im0tn"]
resource_name = "blockLeft"
length = 0.5
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath(".:rotation")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0, 0.5),
"transitions": PackedFloat32Array(1, 0.153893),
"update": 0,
"values": [0.0, 12.5664]
}
tracks/1/type = "value"
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/path = NodePath(".:scale")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/keys = {
"times": PackedFloat32Array(0, 0.5),
"transitions": PackedFloat32Array(1, 1),
"update": 0,
"values": [Vector2(6, 6), Vector2(0, 0)]
}
tracks/2/type = "value"
tracks/2/imported = false
tracks/2/enabled = true
tracks/2/path = NodePath("ColorRect:color:a")
tracks/2/interp = 1
tracks/2/loop_wrap = true
tracks/2/keys = {
"times": PackedFloat32Array(0, 0.5),
"transitions": PackedFloat32Array(1, 1),
"update": 0,
"values": [Color(0, 0, 0, 1), Color(0, 0, 0, 0)]
}

[sub_resource type="AnimationLibrary" id="AnimationLibrary_xfwl5"]
_data = {
&"CaughtBlock": SubResource("Animation_5d32t"),
&"RESET": SubResource("Animation_xfwl5"),
&"blockLeft": SubResource("Animation_im0tn")
}

[node name="Block" type="StaticBody2D"]
z_index = 8
scale = Vector2(6, 6)
collision_layer = 129
input_pickable = true
script = ExtResource("1_im0tn")

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
position = Vector2(8.7456e-08, 8.7456e-08)
scale = Vector2(0.304741, 0.304741)
shape = SubResource("RectangleShape2D_xfwl5")

[node name="SpawnRadius" type="Area2D" parent="."]
show_behind_parent = true
z_as_relative = false
scale = Vector2(1.5, 1.5)
collision_layer = 256
collision_mask = 256
input_pickable = false

[node name="CollisionShape2D2" type="CollisionShape2D" parent="SpawnRadius"]
shape = SubResource("CircleShape2D_im0tn")

[node name="ColorRect" type="ColorRect" parent="."]
material = SubResource("ShaderMaterial_5d32t")
offset_left = -20.0
offset_top = -20.0
offset_right = 20.0
offset_bottom = 20.0
pivot_offset = Vector2(20, 20)
mouse_filter = 2

[node name="GPUParticles2D" type="GPUParticles2D" parent="."]
emitting = false
amount = 50
lifetime = 0.3
one_shot = true
explosiveness = 1.0
randomness = 0.1
process_material = ExtResource("2_5d32t")

[node name="Dead" type="GPUParticles2D" parent="."]
emitting = false
amount = 200
lifetime = 5.0
one_shot = true
speed_scale = 2.0
explosiveness = 0.9
randomness = 0.1
process_material = ExtResource("3_5d32t")

[node name="AnimationPlayer" type="AnimationPlayer" parent="."]
libraries = {
&"": SubResource("AnimationLibrary_xfwl5")
}

[node name="VisibleOnScreenNotifier2D" type="VisibleOnScreenNotifier2D" parent="."]
rect = Rect2(-20, -20, 40, 40)

[connection signal="area_entered" from="SpawnRadius" to="." method="_on_spawn_radius_area_entered"]
[connection signal="animation_finished" from="AnimationPlayer" to="." method="_on_animation_player_animation_finished"]
[connection signal="screen_exited" from="VisibleOnScreenNotifier2D" to="." method="_on_visible_on_screen_notifier_2d_screen_exited"]
